BINARY_WIDTH_GENERIC = 15
NUM_BCD_DIGITS_GENERIC = 5

# Dynamic Power ----------------------------------------------------------------
clk_divider = '\nlibrary IEEE;\
\nuse IEEE.STD_LOGIC_1164.ALL;\
\nuse IEEE.STD_LOGIC_UNSIGNED.ALL;\
\n\
\nentity clk_div is\
\n        Port (\
\n                clk    : in  STD_LOGIC;\
\n                reset  : in  STD_LOGIC;'
clk_divider += ''.join(['\n                clk_{}x : out STD_LOGIC;'.format(i) for i in range(BINARY_WIDTH_GENERIC)])
clk_divider += '\n        );\
\nend entity clk_div;\
\n\
\narchitecture Behavioral of clk_div is\
\n-- Modules ---------------------------------------------------------------------\
\n    component divide_by_2 is\
\n        Port (\
\n                clk    : in  STD_LOGIC;\
\n                reset  : in  STD_LOGIC;\
\n                clk_out: out STD_LOGIC\
\n        );\
\n    end component;'
clk_divider += ''.join(['\n    signal i_clk_{}x : STD_LOGIC := \'0\';'.format(i) for i in range(BINARY_WIDTH_GENERIC)])
clk_divider += '\nbegin\
\n-- Module instantiations -------------------------------------------------------'
clk_divider += '\n    slowed_clk_1: divide_by_2\
\n        Port map (\
\n                    clk     => clk,\
\n                    reset   => reset,\
\n                    clk_out => i_clk_1x\
\n        );\n'
clk_divider += ''.join(['\n    slowed_clk_{}: divide_by_2\
\n        Port map (\
\n                    clk     => i_clk_{},\
\n                    reset   => reset,\
\n                    clk_out => i_clk_{}x\
\n        );\n'.format(i, i-1, i) for i in range(1,BINARY_WIDTH_GENERIC)])
clk_divider += ''.join(['\n    clk_{}x <= i_clk_{}x;'.format(i, i) for i in range(BINARY_WIDTH_GENERIC)])
clk_divider += '\n\
\nend Behavioral;'


divide_by_2 = '\
\nlibrary IEEE;\
\nuse IEEE.STD_LOGIC_1164.ALL;\
\nuse IEEE.STD_LOGIC_UNSIGNED.ALL;\
\n\
\nentity divide_by_2 is\
\n        Port (\
\n                clk    : in  STD_LOGIC;\
\n                reset  : in  STD_LOGIC;\
\n                clk_out: out STD_LOGIC\
\n        );\
\nend entity divide_by_2;\
\n\
\narchitecture Behavioral of divide_by_2 is\
\n    signal i_clk_out: STD_LOGIC := \'0\';\
\nbegin\
\n\
\n    clk_divide_by_2 : process(clk, reset)\
\n    begin\
\n        if reset=\'1\' then\
\n            i_clk_out <= \'0\';\
\n        elsif rising_edge(clk) then\
\n            i_clk_out <= not i_clk_out;\
\n        end if;\
\n    end process;\
\n    \
\n    clk_out <= i_clk_out;\
\n\
\n\
\nend Behavioral;'



dynamic_clk = '\nlibrary IEEE;\
\nuse IEEE.STD_LOGIC_1164.ALL;\
\nuse IEEE.STD_LOGIC_ARITH.ALL;\
\nuse IEEE.STD_LOGIC_UNSIGNED.ALL;\
\n\
\n\
\n-- Dynamic Clk: \
\n--    - Takes a voltage and a clk, and slows down or speeds up the clk based on\
\n--      how much the voltage is changing.\
\n--    - When voltage is changing slowly then you can detect changes to the signal\
\n--      with high accuracy at a slower rate. By using a slower clk cycle you\
\n--      significantly save power (CMOS circuits use almost no static power)\
\n--\
\n-- Internal process:\
\n--    - Compare voltage measured to previous voltages (XOR), the the most \
\n--      significant high bit, eg for "000111111" the bit is 5. Divide the clk by\
\n--      2^(width-1-5) = 2^3 clk cycles.\
\n\
\n\
\nentity dynamic_clk is\
\n        Port (\
\n                clk      : in  STD_LOGIC;\
\n                reset    : in  STD_LOGIC;\
\n                voltage  : in  STD_LOGIC_VECTOR(BINARY_WIDTH_GENERIC-1 downto 0); -- BINARY_WIDTH_GENERIC is width\
\n                out_clk  : out STD_LOGIC\
\n         );\
\nend dynamic_clk;\
\n\
\narchitecture Behavioral of dynamic_clk is\
\n-- Internal modules ------------------------------------------------------------\
\n    component clk_div is\
\n            Port (\
\n                clk    : in  STD_LOGIC;\
\n                reset  : in  STD_LOGIC;\
'
dynamic_clk += ''.join(['\n                clk_{}x : out STD_LOGIC;'.format(i) for i in range(BINARY_WIDTH_GENERIC)])
dynamic_clk += '\n            );\
\n    end component;\
\n-- Internal signals ------------------------------------------------------------\
\n    signal prev_voltage: STD_LOGIC_VECTOR(BINARY_WIDTH_GENERIC-1 downto 0) := (others => \'0\');\
\n    signal diff_voltage: STD_LOGIC_VECTOR(BINARY_WIDTH_GENERIC-1 downto 0) := (others => \'1\'); -- XOR of voltage & prev_voltage\
\n'
dynamic_clk += ''.join(['\n    signal clk_{}x: STD_LOGIC := \'0\';'.format(i) for i in range(1,BINARY_WIDTH_GENERIC)])
dynamic_clk += '\n\
\nbegin\
\n-- Module instantiations -------------------------------------------------------\
\n    clk_divider: clk_div\
\n        port map (\
\n            clk    => clk,\
\n            reset  => reset,'
dynamic_clk += ''.join(['\n            clk_{}x => clk_{}x'.format(i,i) for i in range(1,BINARY_WIDTH_GENERIC)])
dynamic_clk += '\n        );\
\n-- Internal processes ----------------------------------------------------------\
\n    seq : process(clk,reset)\
\n    begin\
\n        if (reset = \'1\') then\
\n            prev_voltage <= (others => \'0\');\
\n            diff_voltage <= (others => \'1\');\
\n            out_clk <= clk;\
\n        elsif (rising_edge(clk)) then -- By using clk \
\n            prev_voltage <= voltage;\
\n            diff_voltage <= voltage XNOR prev_voltage;\
\n        end if;\
\n    end process;\
\n\
\n    slow_clk : process(diff_voltage, clk,'
dynamic_clk += ''.join(['clk_{}x'.format(i,i) for i in range(1,BINARY_WIDTH_GENERIC)])
dynamic_clk += '\n    begin\
\n        if (diff_voltage(9-1) = \'0\') then -- (9-1-0) -- slow clk by 2^0 = same speed\
\n            out_clk <= clk;\
\n        elsif (diff_voltage(9-2) = \'0\') then -- (9-1-1) -- slow clk by 2^1\
\n            out_clk <= clk_1x;\
\n        elsif (diff_voltage(9-3) = \'0\') then -- (9-1-2) -- slow clk by 2^2\
\n            out_clk <= clk_2x;\
\n        elsif (diff_voltage(9-4) = \'0\') then -- (9-1-3) -- slow clk by 2^3\
\n            out_clk <= clk_3x;\
\n        elsif (diff_voltage(9-5) = \'0\') then -- (9-1-4) -- slow clk by 2^4\
\n            out_clk <= clk_4x;\
\n        elsif (diff_voltage(9-6) = \'0\') then -- (9-1-5) -- slow clk by 2^5\
\n            out_clk <= clk_5x;\
\n        elsif (diff_voltage(9-7) = \'0\') then -- (9-1-6) -- slow clk by 2^6\
\n            out_clk <= clk_6x;\
\n        elsif (diff_voltage(9-8) = \'0\') then -- (9-1-7) -- slow clk by 2^7\
\n            out_clk <= clk_7x;\
\n        elsif (diff_voltage(9-9) = \'0\') then -- (9-1-8) -- slow clk by 2^8\
\n            out_clk <= clk_8x;\
\n        end if;\
\n    end process;\
\n\
\nend Behavioral;\
\n'



# # Estimator ----------------------------------------------------------------
# estimator = '\nlibrary IEEE;\
# \n    use IEEE.STD_LOGIC_1164.ALL;\
# \n    use IEEE.STD_LOGIC_ARITH.ALL;\
# \n    use IEEE.STD_LOGIC_UNSIGNED.ALL;\
# \n    \
# \n    entity estimator is\
# \n            generic (width: integer := BINARY_WIDTH_GENERIC);\
# \n            Port (\
# \n                    clk        : in  STD_LOGIC;\
# \n                    reset      : in  STD_LOGIC;\
# \n                    en_dists_cm: in  STD_LOGIC;\
# \n                    en_dists_in: in  STD_LOGIC;\
# \n                    voltage    : in  STD_LOGIC_VECTOR(width-1 downto 0);\
# \n                    distance   : out STD_LOGIC_VECTOR(NUM_BCD_DIGITS_GENERIC*4-1 downto 0)\
# \n            );\
# \n    end estimator;\
# \n    \
# \n    architecture Behavioral of estimator is\
# \n    type ROM is array (0 to 511) of STD_LOGIC_VECTOR(NUM_BCD_DIGITS_GENERIC*4-1 downto 0);\
# \n    constant dists_cm: ROM := (("0111011111000110"), ("0111011011001000"), ("0111010111001001"), ("0111010111000001"), ("0111010011000011"), ("0111001111000101"), ("0111001011000111"), ("0111000111001001"), ("0111000111000001"), ("0111000011000011"), ("0110100111000101"), ("0110100011000111"), ("0110100011000000"), ("0110011111000010"), ("0110011011000101"), ("0110010111000111"), ("0110010111000000"), ("0110010011000011"), ("0110001111000101"), ("0110001011001000"), ("0110001011000001"), ("0110000111000100"), ("0110000011000111"), ("0110000011000001"), ("0101100111000100"), ("0101100011000111"), ("0101100011000001"), ("0101011111000100"), ("0101011011001000"), ("0101011011000001"), ("0101010111000101"), ("0101010011001000"), ("0101010011000010"), ("0101001111000110"), ("0101001111000000"), ("0101001011000100"), ("0101000111001000"), ("0101000111000010"), ("0101000011000110"), ("0101000011000000"), ("0100100111000101"), ("0100100011001001"), ("0100100011000011"), ("0100011111001000"), ("0100011111000010"), ("0100011011000111"), ("0100011011000010"), ("0100010111000110"), ("0100010111000001"), ("0100010011000110"), ("0100010011000001"), ("0100001111000110"), ("0100001111000001"), ("0100001011000110"), ("0100001011000001"), ("0100000111000110"), ("0100000111000001"), ("0100000011000110"), ("0100000011000010"), ("0011100111000111"), ("0011100111000011"), ("0011100011001000"), ("0011100011000100"), ("0011011111001001"), ("0011011111000101"), ("0011011111000000"), ("0011011011000110"), ("0011011011000010"), ("0011010111001000"), ("0011010111000100"), ("0011010111000000"), ("0011010011000110"), ("0011010011000010"), ("0011001111001000"), ("0011001111000100"), ("0011001111000000"), ("0011001011000110"), ("0011001011000010"), ("0011000111001001"), ("0011000111000101"), ("0011000111000001"), ("0011000011001000"), ("0011000011000100"), ("0011000011000001"), ("0010100111000111"), ("0010100111000100"), ("0010100111000001"), ("0010100011000111"), ("0010100011000100"), ("0010100011000001"), ("0010011111001000"), ("0010011111000100"), ("0010011111000001"), ("0010011011001000"), ("0010011011000101"), ("0010011011000010"), ("0010010111001001"), ("0010010111000110"), ("0010010111000011"), ("0010010111000001"), ("0010010011001000"), ("0010010011000101"), ("0010010011000010"), ("0010001111001001"), ("0010001111000111"), ("0010001111000100"), ("0010001111000010"), ("0010001011001001"), ("0010001011000111"), ("0010001011000100"), ("0010001011000010"), ("0010000111001001"), ("0010000111000111"), ("0010000111000100"), ("0010000111000010"), ("0010000111000000"), ("0010000011000111"), ("0010000011000101"), ("0010000011000011"), ("0010000011000001"), ("0001100111001001"), ("0001100111000111"), ("0001100111000101"), ("0001100111000010"), ("0001100111000000"), ("0001100011001000"), ("0001100011000110"), ("0001100011000101"), ("0001100011000011"), ("0001100011000001"), ("0001011111001001"), ("0001011111000111"), ("0001011111000101"), ("0001011111000011"), ("0001011111000010"), ("0001011111000000"), ("0001011011001000"), ("0001011011000111"), ("0001011011000101"), ("0001011011000011"), ("0001011011000010"), ("0001011011000000"), ("0001010111001001"), ("0001010111000111"), ("0001010111000101"), ("0001010111000100"), ("0001010111000011"), ("0001010111000001"), ("0001010111000000"), ("0001010011001000"), ("0001010011000111"), ("0001010011000101"), ("0001010011000100"), ("0001010011000011"), ("0001010011000010"), ("0001010011000000"), ("0001001111001001"), ("0001001111001000"), ("0001001111000111"), ("0001001111000101"), ("0001001111000100"), ("0001001111000011"), ("0001001111000010"), ("0001001111000001"), ("0001001111000000"), ("0001001011001000"), ("0001001011000111"), ("0001001011000110"), ("0001001011000101"), ("0001001011000100"), ("0001001011000011"), ("0001001011000010"), ("0001001011000001"), ("0001001011000000"), ("0001000111001001"), ("0001000111001000"), ("0001000111000111"), ("0001000111000111"), ("0001000111000110"), ("0001000111000101"), ("0001000111000100"), ("0001000111000011"), ("0001000111000010"), ("0001000111000001"), ("0001000111000001"), ("0001000111000000"), ("0001000011001001"), ("0001000011001000"), ("0001000011000111"), ("0001000011000111"), ("0001000011000110"), ("0001000011000101"), ("0001000011000100"), ("0001000011000100"), ("0001000011000011"), ("0001000011000010"), ("0001000011000010"), ("0001000011000001"), ("0001000011000000"), ("0001000011000000"), ("1001110010010110"), ("1001110010001001"), ("1001110010000011"), ("1001110001110111"), ("1001110001110001"), ("1001110001100101"), ("1001110001011001"), ("1001110001010100"), ("1001110001001000"), ("1001110001000010"), ("1001110000110111"), ("1001110000110001"), ("1001110000100110"), ("1001110000100001"), ("1001110000010110"), ("1001110000010001"), ("1001110000000110"), ("1001110000000001"), ("1000110010010110"), ("1000110010010001"), ("1000110010000110"), ("1000110010000001"), ("1000110001110111"), ("1000110001110010"), ("1000110001101000"), ("1000110001100011"), ("1000110001011001"), ("1000110001010100"), ("1000110001010000"), ("1000110001000110"), ("1000110001000001"), ("1000110000110111"), ("1000110000110011"), ("1000110000101001"), ("1000110000100101"), ("1000110000100001"), ("1000110000010111"), ("1000110000010011"), ("1000110000001001"), ("1000110000000101"), ("1000110000000001"), ("0111110010011000"), ("0111110010010100"), ("0111110010010000"), ("0111110010000111"), ("0111110010000011"), ("0111110001111001"), ("0111110001110110"), ("0111110001110010"), ("0111110001101001"), ("0111110001100101"), ("0111110001100010"), ("0111110001011000"), ("0111110001010101"), ("0111110001010001"), ("0111110001001000"), ("0111110001000101"), ("0111110001000001"), ("0111110000111000"), ("0111110000110101"), ("0111110000110001"), ("0111110000101000"), ("0111110000100101"), ("0111110000100001"), ("0111110000011000"), ("0111110000010101"), ("0111110000010010"), ("0111110000001001"), ("0111110000000101"), ("0111110000000010"), ("0110110010011001"), ("0110110010010110"), ("0110110010010011"), ("0110110010010000"), ("0110110010000110"), ("0110110010000011"), ("0110110010000000"), ("0110110001110111"), ("0110110001110100"), ("0110110001110001"), ("0110110001101000"), ("0110110001100101"), ("0110110001100001"), ("0110110001011000"), ("0110110001010101"), ("0110110001010010"), ("0110110001001001"), ("0110110001000110"), ("0110110001000011"), ("0110110001000000"), ("0110110000110111"), ("0110110000110011"), ("0110110000110000"), ("0110110000100111"), ("0110110000100100"), ("0110110000100001"), ("0110110000011000"), ("0110110000010101"), ("0110110000010010"), ("0110110000001000"), ("0110110000000101"), ("0110110000000010"), ("0101110010011001"), ("0101110010010110"), ("0101110010010011"), ("0101110010010000"), ("0101110010000111"), ("0101110010000011"), ("0101110010000000"), ("0101110001110111"), ("0101110001110100"), ("0101110001110001"), ("0101110001101000"), ("0101110001100100"), ("0101110001100001"), ("0101110001011000"), ("0101110001010101"), ("0101110001010010"), ("0101110001001001"), ("0101110001000101"), ("0101110001000010"), ("0101110000111001"), ("0101110000110110"), ("0101110000110011"), ("0101110000101001"), ("0101110000100110"), ("0101110000100011"), ("0101110000100000"), ("0101110000010111"), ("0101110000010011"), ("0101110000010000"), ("0101110000000111"), ("0101110000000100"), ("0101110000000001"), ("0100110010010111"), ("0100110010010100"), ("0100110010010001"), ("0100110010001000"), ("0100110010000101"), ("0100110010000010"), ("0100110001111000"), ("0100110001110101"), ("0100110001110010"), ("0100110001101001"), ("0100110001100110"), ("0100110001100011"), ("0100110001100000"), ("0100110001010111"), ("0100110001010011"), ("0100110001010000"), ("0100110001000111"), ("0100110001000100"), ("0100110001000001"), ("0100110000111000"), ("0100110000110101"), ("0100110000110010"), ("0100110000101001"), ("0100110000100110"), ("0100110000100011"), ("0100110000100000"), ("0100110000010111"), ("0100110000010100"), ("0100110000010010"), ("0100110000001001"), ("0100110000000110"), ("0100110000000011"), ("0100110000000000"), ("0011110010011000"), ("0011110010010101"), ("0011110010010010"), ("0011110010010000"), ("0011110010000111"), ("0011110010000100"), ("0011110010000010"), ("0011110001111001"), ("0011110001110111"), ("0011110001110100"), ("0011110001110010"), ("0011110001110000"), ("0011110001100111"), ("0011110001100101"), ("0011110001100011"), ("0011110001100000"), ("0011110001011000"), ("0011110001010110"), ("0011110001010100"), ("0011110001010010"), ("0011110001010000"), ("0011110001001000"), ("0011110001000110"), ("0011110001000100"), ("0011110001000011"), ("0011110001000001"), ("0011110000111001"), ("0011110000111000"), ("0011110000110110"), ("0011110000110101"), ("0011110000110011"), ("0011110000110010"), ("0011110000110001"), ("0011110000110000"), ("0011110000101001"), ("0011110000101000"), ("0011110000100111"), ("0011110000100110"), ("0011110000100101"), ("0011110000100100"), ("0011110000100011"), ("0011110000100011"), ("0011110000100010"), ("0011110000100010"), ("0011110000100010"), ("0011110000100001"), ("0011110000100001"), ("0011110000100001"), ("0011110000100001"), ("0011110000100010"), ("0011110000100010"), ("0011110000100010"), ("0011110000100011"), ("0011110000100011"), ("0011110000100100"), ("0011110000100101"), ("0011110000100101"), ("0011110000100110"), ("0011110000101000"), ("0011110000101001"), ("0011110000110000"), ("0011110000110010"), ("0011110000110011"), ("0011110000110101"), ("0011110000110111"), ("0011110000111001"), ("0011110001000001"), ("0011110001000011"), ("0011110001000110"), ("0011110001001000"), ("0011110001010001"), ("0011110001010011"), ("0011110001010110"), ("0011110001011001"), ("0011110001100011"), ("0011110001100110"), ("0011110001110000"), ("0011110001110011"), ("0011110001110111"), ("0011110010000001"), ("0011110010000101"), ("0011110010010000"), ("0011110010010100"), ("0011110010011001"), ("0100110000000100"), ("0100110000001001"), ("0100110000010100"), ("0100110000011001"), ("0100110000100101"), ("0100110000110001"), ("0100110000110111"), ("0100110001000011"), ("0100110001001001"), ("0100110001010110"), ("0100110001100010"), ("0100110001101001"), ("0100110001110110"), ("0100110010000100"), ("0100110010010001"), ("0100110010011001"), ("0101110000000111"), ("0101110000010101"), ("0101110000100100"), ("0101110000110010"), ("0101110001000001"), ("0101110001010000"), ("0101110001011001"), ("0101110001101001"), ("0101110001111001"), ("0101110010001001"), ("0101110010011001"), ("0110110000010000"), ("0110110000100000"), ("0110110000110001"), ("0110110001000011"), ("0110110001010100"), ("0110110001100110"), ("0110110001111000"), ("0110110010010000"), ("0111110000000011"), ("0111110000010110"), ("0111110000101001"), ("0111110001000010"), ("0111110001010110"), ("0111110001110000"), ("0111110010000100"), ("0111110010011001"), ("1000110000010100"), ("1000110000101001"), ("1000110001000100"), ("1000110001100000"), ("1000110001110110"), ("1000110010010010"), ("1001110000001001"), ("1001110000100110"), ("1001110001000011"), ("1001110001100001"), ("1001110001111001"), ("1001110010010111"), ("0001000011000001"), ("0001000011000011"), ("0001000011000101"), ("0001000011000111"), ("0001000011001001"), ("0001000111000001"));\
# \n    constant dists_in: ROM := (("0011000011000101"), ("0011000011000010"), ("0010100111001001"), ("0010100111000101"), ("0010100111000010"), ("0010100011001001"), ("0010100011000110"), ("0010100011000011"), ("0010011111001001"), ("0010011111000110"), ("0010011111000011"), ("0010011111000000"), ("0010011011000111"), ("0010011011000100"), ("0010011011000001"), ("0010010111001000"), ("0010010111000110"), ("0010010111000011"), ("0010010111000000"), ("0010010011000111"), ("0010010011000100"), ("0010010011000010"), ("0010001111001001"), ("0010001111000110"), ("0010001111000100"), ("0010001111000001"), ("0010001011001000"), ("0010001011000110"), ("0010001011000011"), ("0010001011000001"), ("0010000111001000"), ("0010000111000110"), ("0010000111000011"), ("0010000111000001"), ("0010000011001000"), ("0010000011000110"), ("0010000011000100"), ("0010000011000001"), ("0001100111001001"), ("0001100111000111"), ("0001100111000100"), ("0001100111000010"), ("0001100111000000"), ("0001100011001000"), ("0001100011000110"), ("0001100011000100"), ("0001100011000001"), ("0001011111001001"), ("0001011111000111"), ("0001011111000101"), ("0001011111000011"), ("0001011111000001"), ("0001011011001001"), ("0001011011000111"), ("0001011011000101"), ("0001011011000011"), ("0001011011000010"), ("0001011011000000"), ("0001010111001000"), ("0001010111000110"), ("0001010111000100"), ("0001010111000010"), ("0001010111000001"), ("0001010011001001"), ("0001010011000111"), ("0001010011000110"), ("0001010011000100"), ("0001010011000010"), ("0001010011000001"), ("0001001111001001"), ("0001001111000111"), ("0001001111000110"), ("0001001111000100"), ("0001001111000011"), ("0001001111000001"), ("0001001111000000"), ("0001001011001000"), ("0001001011000111"), ("0001001011000101"), ("0001001011000100"), ("0001001011000010"), ("0001001011000001"), ("0001000111001001"), ("0001000111001000"), ("0001000111000111"), ("0001000111000101"), ("0001000111000100"), ("0001000111000011"), ("0001000111000001"), ("0001000111000000"), ("0001000011001001"), ("0001000011001000"), ("0001000011000110"), ("0001000011000101"), ("0001000011000100"), ("0001000011000011"), ("0001000011000010"), ("0001000011000001"), ("1001110010011001"), ("1001110010001000"), ("1001110001110111"), ("1001110001100110"), ("1001110001010101"), ("1001110001000100"), ("1001110000110100"), ("1001110000100011"), ("1001110000010011"), ("1001110000000011"), ("1000110010010011"), ("1000110010000011"), ("1000110001110100"), ("1000110001100100"), ("1000110001010101"), ("1000110001000101"), ("1000110000110110"), ("1000110000100111"), ("1000110000011000"), ("1000110000010000"), ("1000110000000001"), ("0111110010010010"), ("0111110010000100"), ("0111110001110110"), ("0111110001100111"), ("0111110001011001"), ("0111110001010001"), ("0111110001000011"), ("0111110000110110"), ("0111110000101000"), ("0111110000100000"), ("0111110000010011"), ("0111110000000110"), ("0110110010011000"), ("0110110010010001"), ("0110110010000100"), ("0110110001110111"), ("0110110001110001"), ("0110110001100100"), ("0110110001010111"), ("0110110001010001"), ("0110110001000100"), ("0110110000111000"), ("0110110000110010"), ("0110110000100110"), ("0110110000100000"), ("0110110000010100"), ("0110110000001000"), ("0110110000000010"), ("0101110010010110"), ("0101110010010001"), ("0101110010000101"), ("0101110010000000"), ("0101110001110100"), ("0101110001101001"), ("0101110001100100"), ("0101110001011001"), ("0101110001010100"), ("0101110001001001"), ("0101110001000100"), ("0101110000111001"), ("0101110000110100"), ("0101110000101001"), ("0101110000100101"), ("0101110000100000"), ("0101110000010110"), ("0101110000010001"), ("0101110000000111"), ("0101110000000011"), ("0100110010011001"), ("0100110010010101"), ("0100110010010001"), ("0100110010000111"), ("0100110010000011"), ("0100110001111001"), ("0100110001110101"), ("0100110001110001"), ("0100110001100111"), ("0100110001100100"), ("0100110001100000"), ("0100110001010111"), ("0100110001010011"), ("0100110001010000"), ("0100110001000110"), ("0100110001000011"), ("0100110001000000"), ("0100110000110111"), ("0100110000110100"), ("0100110000110000"), ("0100110000100111"), ("0100110000100100"), ("0100110000100001"), ("0100110000011000"), ("0100110000010110"), ("0100110000010011"), ("0100110000010000"), ("0100110000000111"), ("0100110000000101"), ("0100110000000010"), ("0011110010011001"), ("0011110010010111"), ("0011110010010100"), ("0011110010010010"), ("0011110010001001"), ("0011110010000111"), ("0011110010000100"), ("0011110010000010"), ("0011110010000000"), ("0011110001110111"), ("0011110001110101"), ("0011110001110011"), ("0011110001110001"), ("0011110001101001"), ("0011110001100110"), ("0011110001100100"), ("0011110001100010"), ("0011110001100000"), ("0011110001011000"), ("0011110001010110"), ("0011110001010100"), ("0011110001010010"), ("0011110001010000"), ("0011110001001001"), ("0011110001000111"), ("0011110001000101"), ("0011110001000011"), ("0011110001000001"), ("0011110000111001"), ("0011110000111000"), ("0011110000110110"), ("0011110000110100"), ("0011110000110011"), ("0011110000110001"), ("0011110000101001"), ("0011110000101000"), ("0011110000100110"), ("0011110000100100"), ("0011110000100011"), ("0011110000100001"), ("0011110000100000"), ("0011110000011000"), ("0011110000010111"), ("0011110000010101"), ("0011110000010100"), ("0011110000010010"), ("0011110000010001"), ("0011110000001001"), ("0011110000001000"), ("0011110000000111"), ("0011110000000101"), ("0011110000000100"), ("0011110000000010"), ("0011110000000001"), ("0011110000000000"), ("0010110010011000"), ("0010110010010111"), ("0010110010010110"), ("0010110010010100"), ("0010110010010011"), ("0010110010010010"), ("0010110010010000"), ("0010110010001001"), ("0010110010001000"), ("0010110010000110"), ("0010110010000101"), ("0010110010000100"), ("0010110010000010"), ("0010110010000001"), ("0010110010000000"), ("0010110001111001"), ("0010110001110111"), ("0010110001110110"), ("0010110001110101"), ("0010110001110100"), ("0010110001110010"), ("0010110001110001"), ("0010110001110000"), ("0010110001101001"), ("0010110001100111"), ("0010110001100110"), ("0010110001100101"), ("0010110001100100"), ("0010110001100011"), ("0010110001100001"), ("0010110001100000"), ("0010110001011001"), ("0010110001011000"), ("0010110001010110"), ("0010110001010101"), ("0010110001010100"), ("0010110001010011"), ("0010110001010010"), ("0010110001010000"), ("0010110001001001"), ("0010110001001000"), ("0010110001000111"), ("0010110001000101"), ("0010110001000100"), ("0010110001000011"), ("0010110001000010"), ("0010110001000000"), ("0010110000111001"), ("0010110000111000"), ("0010110000110111"), ("0010110000110110"), ("0010110000110100"), ("0010110000110011"), ("0010110000110010"), ("0010110000110001"), ("0010110000101001"), ("0010110000101000"), ("0010110000100111"), ("0010110000100110"), ("0010110000100100"), ("0010110000100011"), ("0010110000100010"), ("0010110000100001"), ("0010110000011001"), ("0010110000011000"), ("0010110000010111"), ("0010110000010110"), ("0010110000010100"), ("0010110000010011"), ("0010110000010010"), ("0010110000010001"), ("0010110000001001"), ("0010110000001000"), ("0010110000000111"), ("0010110000000110"), ("0010110000000100"), ("0010110000000011"), ("0010110000000010"), ("0010110000000001"), ("0001110010011001"), ("0001110010011000"), ("0001110010010111"), ("0001110010010110"), ("0001110010010100"), ("0001110010010011"), ("0001110010010010"), ("0001110010010001"), ("0001110010001001"), ("0001110010001000"), ("0001110010000111"), ("0001110010000110"), ("0001110010000100"), ("0001110010000011"), ("0001110010000010"), ("0001110010000001"), ("0001110001111001"), ("0001110001111000"), ("0001110001110111"), ("0001110001110110"), ("0001110001110101"), ("0001110001110011"), ("0001110001110010"), ("0001110001110001"), ("0001110001110000"), ("0001110001101001"), ("0001110001100111"), ("0001110001100110"), ("0001110001100101"), ("0001110001100100"), ("0001110001100011"), ("0001110001100010"), ("0001110001100001"), ("0001110001100000"), ("0001110001011000"), ("0001110001010111"), ("0001110001010110"), ("0001110001010101"), ("0001110001010100"), ("0001110001010011"), ("0001110001010010"), ("0001110001010001"), ("0001110001010000"), ("0001110001001001"), ("0001110001001000"), ("0001110001000111"), ("0001110001000110"), ("0001110001000101"), ("0001110001000100"), ("0001110001000011"), ("0001110001000010"), ("0001110001000010"), ("0001110001000001"), ("0001110001000000"), ("0001110000111001"), ("0001110000111000"), ("0001110000111000"), ("0001110000110111"), ("0001110000110110"), ("0001110000110101"), ("0001110000110101"), ("0001110000110100"), ("0001110000110011"), ("0001110000110011"), ("0001110000110010"), ("0001110000110010"), ("0001110000110001"), ("0001110000110000"), ("0001110000110000"), ("0001110000101001"), ("0001110000101001"), ("0001110000101001"), ("0001110000101000"), ("0001110000101000"), ("0001110000101000"), ("0001110000100111"), ("0001110000100111"), ("0001110000100111"), ("0001110000100111"), ("0001110000100110"), ("0001110000100110"), ("0001110000100110"), ("0001110000100110"), ("0001110000100110"), ("0001110000100110"), ("0001110000100110"), ("0001110000100110"), ("0001110000100111"), ("0001110000100111"), ("0001110000100111"), ("0001110000100111"), ("0001110000100111"), ("0001110000101000"), ("0001110000101000"), ("0001110000101001"), ("0001110000101001"), ("0001110000110000"), ("0001110000110000"), ("0001110000110001"), ("0001110000110010"), ("0001110000110010"), ("0001110000110011"), ("0001110000110100"), ("0001110000110101"), ("0001110000110110"), ("0001110000110111"), ("0001110000111000"), ("0001110000111001"), ("0001110001000000"), ("0001110001000001"), ("0001110001000011"), ("0001110001000100"), ("0001110001000101"), ("0001110001000111"), ("0001110001001000"), ("0001110001010000"), ("0001110001010001"), ("0001110001010011"), ("0001110001010101"), ("0001110001010111"), ("0001110001011001"), ("0001110001100001"), ("0001110001100011"), ("0001110001100101"), ("0001110001100111"), ("0001110001101001"), ("0001110001110010"), ("0001110001110100"), ("0001110001110111"), ("0001110001111001"), ("0001110010000010"), ("0001110010000100"), ("0001110010000111"), ("0001110010010000"), ("0001110010010011"), ("0001110010010110"), ("0001110010011001"), ("0010110000000011"), ("0010110000000110"), ("0010110000001001"), ("0010110000010011"), ("0010110000010110"), ("0010110000100000"), ("0010110000100100"), ("0010110000101000"), ("0010110000110010"), ("0010110000110110"), ("0010110001000000"), ("0010110001000100"), ("0010110001001000"), ("0010110001010011"), ("0010110001010111"), ("0010110001100010"), ("0010110001100111"), ("0010110001110001"), ("0010110001110110"), ("0010110010000001"), ("0010110010000111"), ("0010110010010010"), ("0010110010010111"), ("0011110000000011"), ("0011110000001000"), ("0011110000010100"), ("0011110000100000"), ("0011110000100110"), ("0011110000110010"), ("0011110000111000"), ("0011110001000101"), ("0011110001010001"), ("0011110001011000"), ("0011110001100100"), ("0011110001110001"), ("0011110001111000"), ("0011110010000101"), ("0011110010010010"), ("0100110000000000"), ("0100110000000111"), ("0100110000010101"), ("0100110000100010"), ("0100110000110000"), ("0100110000111000"));\
# \n\
# \n    begin\
# \n    -- Internal processes ----------------------------------------------------------\
# \n    select_rom : process(voltage, en_dists_cm, en_dists_in)\
# \n    begin\
# \n        if (en_dists_cm = \'1\') then\
# \n            distance <= dists_cm(CONV_INTEGER(UNSIGNED(voltage)));\
# \n        elsif (en_dists_in = \'1\') then\
# \n            distance <= dists_in(CONV_INTEGER(UNSIGNED(voltage)));\
# \n        else\
# \n            distance <= "1111" & "1111" & "1111" & "1111";\
# \n        end if;\
# \n    end process ; -- select_rom\
# \n    \
# \nend Behavioral;\
# \n'




# Signal Generator -------------------------------------------------------------
PWM_DAC = 'library IEEE;\
\nuse IEEE.STD_LOGIC_1164.ALL;\
\nuse IEEE.STD_LOGIC_UNSIGNED.ALL;\
\n\
\nentity PWM_DAC is\
\n    Port ( \
\n           clk : in STD_LOGIC;\
\n           reset : in STD_LOGIC;\
\n           duty_cycle : in STD_LOGIC_VECTOR (9-1 downto 0); -- 9 is width\
\n           pwm_out : out STD_LOGIC\
\n          );\
\nend PWM_DAC;\
\n\
\narchitecture Behavioral of PWM_DAC is\
\n--    signal counter : STD_LOGIC_VECTOR (9 downto 0); -- original\
\n    signal counter : STD_LOGIC_VECTOR (9-1 downto 0); -- corrected -- 9 is width\
\n        \
\nbegin\
\n    count : process(clk,reset)\
\n    begin\
\n        if( reset = \'1\') then\
\n            counter <= (others => \'0\');\
\n        elsif (rising_edge(clk)) then \
\n            counter <= counter + \'1\';\
\n        end if;\
\n    end process;\
\n  \
\n    compare : process(counter, duty_cycle)\
\n    begin    \
\n        if (counter < duty_cycle) then\
\n            pwm_out <= \'1\';\
\n        else \
\n            pwm_out <= \'0\';\
\n        end if;\
\n    end process;\
\n  \
\nend Behavioral;\
'




signal_gen = 'library IEEE;\
\nuse IEEE.STD_LOGIC_1164.ALL;\
\nuse IEEE.STD_LOGIC_UNSIGNED.ALL;\
\n\
\nentity signal_gen is\
\n    Port (\
\n            clk         : in  STD_LOGIC;\
\n            reset       : in  STD_LOGIC;\
\n            comparator  : in  STD_LOGIC; -- If 1: increase voltage, If 0: decrease\
\n            voltage     : out STD_LOGIC_VECTOR(9-1 downto 0); -- 9 is width\
\n            pwm_out     : out STD_LOGIC\
\n     );\
\nend signal_gen;\
\n\
\narchitecture Behavioral of signal_gen is\
\n-- Modules ---------------------------------------------------------------------\
\n    component PWM_DAC is\
\n        Port (\
\n               reset      : in STD_LOGIC;\
\n               clk        : in STD_LOGIC;\
\n               duty_cycle : in STD_LOGIC_VECTOR (9-1 downto 0); -- 9 is width\
\n               pwm_out    : out STD_LOGIC\
\n              );\
\n    end component;\
\n\
\n-- Internal Signals ------------------------------------------------------------\
\n    signal i_voltage     : STD_LOGIC_VECTOR(9-1 downto 0) := (others => \'0\'); -- 9 is width\
\n    signal i_voltage_prev: STD_LOGIC_VECTOR(9-1 downto 0) := (others => \'0\'); -- 9 is width\
\n    signal current_voltage: STD_LOGIC_VECTOR(9-1 downto 0) := (others => \'0\'); -- 9 is width\
\n    signal counter : STD_LOGIC_VECTOR (12-1 downto 0); -- update along with pwm DAC\
\n    \
\n    signal enable: STD_LOGIC := \'0\';\
\n\
\n\
\nbegin\
\n-- Internal processes ----------------------------------------------------------\
\n    count : process(clk,reset)\
\n    begin\
\n        if( reset = \'1\') then\
\n            counter <= (others => \'0\');\
\n            enable <= \'0\';\
\n        elsif (rising_edge(clk)) then\
\n            if (counter = "111111111111") then\
\n                enable <=  \'1\';\
\n            elsif (enable = \'1\') then\
\n                enable <= \'0\';\
\n            end if;\
\n            counter <= counter + \'1\';\
\n        end if;\
\n    end process;\
\n\
\n    check_real_voltage: process(clk, reset) -- Todo: fix to remove bit bobble\
\n    begin\
\n        if (reset = \'1\') then\
\n            current_voltage <= (others => \'0\');\
\n            i_voltage <= (others => \'0\');\
\n            i_voltage_prev <= (others => \'0\');\
\n\
\n        elsif (rising_edge(clk)) then\
\n            if (enable = \'1\') then\
\n                if (comparator = \'1\') then\
\n                    i_voltage <= i_voltage + 1;\
\n                    i_voltage_prev <= i_voltage;\
\n                else\
\n                    i_voltage <= (others => \'0\');\
\n                    current_voltage <= i_voltage_prev;\
\n                end if;\
\n\
\n            end if;\
\n        end if;\
\n    end process ; -- check_real_voltage\
\n    \
\n    voltage <= current_voltage;\
\n\
\n-- Module instantiation --------------------------------------------------------\
\n    PWM_DAC_OUTPUT: PWM_DAC\
\n        Port map (\
\n                   clk         => clk,\
\n                   reset       => reset,\
\n                   duty_cycle  => i_voltage,\
\n                   pwm_out     => pwm_out\
\n               );\
\n\
\nend Behavioral;\
\n'





# VGA --------------------------------------------------------------------------

'\nlibrary IEEE;\
\nuse IEEE.STD_LOGIC_1164.ALL;\
\n\
\nentity clock_divider is\
\n    Port ( clk : in  STD_LOGIC;\
\n           reset : in  STD_LOGIC;\
\n           enable: in STD_LOGIC;\
\n		   kHz: out STD_LOGIC;	  \
\n		   -- added in lab 2:\
\n		   seconds_port: out STD_LOGIC_VECTOR(4-1 downto 0);\
\n		   ten_seconds_port: out STD_LOGIC_VECTOR(3-1 downto 0);\
\n		   minutes_port: out STD_LOGIC_VECTOR(4-1 downto 0);\
\n		   ten_minutes_port: out STD_LOGIC_VECTOR(3-1 downto 0);\
\n		   -- ADDED:\
\n		   twentyfive_MHz: out STD_LOGIC;\
\n		   --daHz: out STD_LOGIC\
\n		   Hz: out STD_LOGIC\
\n		  );\
\nend clock_divider;\
\n\
\narchitecture Behavioral of clock_divider is\
\n-- Signals:\
\nsignal i_enable: STD_LOGIC;\
\nsignal kilohertz: STD_LOGIC;\
\nsignal hundredhertz: STD_LOGIC;\
\nsignal tenhertz: STD_LOGIC;\
\nsignal onehertz: STD_LOGIC;\
\nsignal tensec: STD_LOGIC;\
\nsignal onemin: STD_LOGIC;\
\nsignal tenmin: STD_LOGIC;\
\n\
\nsignal seconds_value: STD_LOGIC_VECTOR(4-1 downto 0);\
\nsignal ten_seconds_value: STD_LOGIC_VECTOR(3-1 downto 0);\
\nsignal minutes_value: STD_LOGIC_VECTOR(4-1 downto 0);\
\nsignal ten_minutes_value: STD_LOGIC_VECTOR(3-1 downto 0);\
\n\
\n-- Components:\
\n-- This is kind of like a function prototype in C/C++\
\ncomponent downcounter is\
\n	Generic ( period: integer:= 4;\
\n				WIDTH: integer:= 3);\
\n		Port ( clk : in  STD_LOGIC;\
\n				  reset : in  STD_LOGIC;\
\n				  enable : in  STD_LOGIC;\
\n				  zero : out  STD_LOGIC;\
\n				  value: out STD_LOGIC_VECTOR(WIDTH-1 downto 0));\
\nend component;\
\nbegin\
\n\
\n-- ADDED\
\nmegaHzClock_25MHz: downcounter\
\ngeneric map(\
\n				period => (4-1), -- divide by 4\
\n				WIDTH => 2\
\n			)\
\nport map (\
\n				clk => clk,\
\n				reset => reset,\
\n				enable => \'1\',\
\n				zero => twentyfive_MHz,\
\n				value => open			-- Leave open since we won\'t display this value\
\n);\
\n\
\nkiloHzClock: downcounter\
\ngeneric map(\
\n				period => (100000-1), -- "1 1000 0110 1010 0000" in binary\
\n				WIDTH => 17\
\n			)\
\nport map (\
\n				clk => clk,\
\n				reset => reset,\
\n				enable => \'1\',\
\n				zero => kilohertz,\
\n				value => open			-- Leave open since we won\'t display this value\
\n);\
\n\
\nhundredHzClock: downcounter\
\ngeneric map(\
\n				period => (10-1),	-- Counts numbers between 0 and 9 -> that\'s 10 values!\
\n				WIDTH => 4\
\n			)\
\nport map (\
\n				clk => clk,\
\n				reset => reset,\
\n				enable => i_enable,\
\n				zero => hundredhertz,\
\n				value => open			-- Leave open since we won\'t display this value\
\n);\
\n\
\ntenHzClock: downcounter\
\ngeneric map(\
\n				period => (10-1),	-- Counts numbers between 0 and 9 -> that\'s 10 values!\
\n				WIDTH => 4\
\n			)\
\nport map (\
\n				clk => clk,\
\n				reset => reset,\
\n				enable => hundredhertz,\
\n				zero => tenhertz,\
\n				value => open			-- Leave open since we won\'t display this value\
\n);\
\n\
\noneHzClock: downcounter\
\ngeneric map(\
\n				period => (10-1),	-- Counts numbers between 0 and 9 -> that\'s 10 values!\
\n				WIDTH => 4\
\n			)\
\nport map (\
\n				clk => clk,\
\n				reset => reset,\
\n				enable => tenhertz,\
\n				zero => onehertz,\
\n				value => open			-- Leave open since we won\'t display this value\
\n);\
\n\
\nsingleSecondsClock: downcounter\
\ngeneric map(\
\n				period => (10-1),	-- Counts numbers between 0 and 9 -> that\'s 10 values!\
\n				WIDTH => 4\
\n			)\
\nport map (\
\n				clk => clk,\
\n				reset => reset,\
\n				enable => onehertz,\
\n				zero => tensec,\
\n				value => seconds_value			\
\n);\
\n\
\ntensSecondsClock: downcounter\
\ngeneric map(\
\n				period => (6-1),	-- Counts numbers between 0 and 5 -> that\'s 6 values!\
\n				WIDTH => 3\
\n			)\
\nport map (\
\n				clk => clk,\
\n				reset => reset,\
\n				enable => tensec,\
\n				zero => onemin,\
\n				value => ten_seconds_value			\
\n);\
\n\
\nsingleMinutesClock: downcounter\
\ngeneric map(\
\n				period => (10-1),	-- Counts numbers between 0 and 9 -> that\'s 10 values!\
\n				WIDTH => 4\
\n			)\
\nport map (\
\n				clk => clk,\
\n				reset => reset,\
\n				enable => onemin,\
\n				zero => tenmin,\
\n				value => minutes_value			\
\n);\
\n\
\ntensMinutesClock: downcounter\
\ngeneric map(\
\n				period => (6-1),	-- Counts numbers between 0 and 5 -> that\'s 6 values!\
\n				WIDTH => 3\
\n			)\
\nport map (\
\n				clk => clk,\
\n				reset => reset,\
\n				enable => tenmin,\
\n				zero => open,\
\n				value => ten_minutes_value			\
\n);\
\n\
\ni_enable <= kilohertz and enable;\
\n\
\n-- Connect internal signals to outputs\
\nkHz <= kilohertz;\
\n\
\n-- added in lab 2:\
\nseconds_port <= seconds_value;\
\nten_seconds_port <= ten_seconds_value;\
\nminutes_port <= minutes_value;\
\nten_minutes_port <= ten_minutes_value;\
\n\
\n-- ADDED:\
\n--daHz <= tenhertz;\
\nHz <= onehertz;\
\n\
\nend Behavioral;'




digits_box = '\n--\
\n--    Digits Box: takes in 3 digits (from 0 to 9) and prints those digits on the \
\n--                vga monitor.\
\n--    \
\n--    Module of:\
\n--        - vga_module\
\n--\
\n--    Internal singals:\
\n--        - sig_0 - sig_10: A 5x5 matrix that contains a digit from 0-9\
\n--        - sig_dec: A matrix the contains an image of a decimal point\
\n--        - box_loc_x/y_min/max: Min and max indices from x and y\
\n--        - pixel_color: Colour of an individual pixel\
\n\
\n\
\nlibrary IEEE;\
\nuse IEEE.STD_LOGIC_1164.ALL;\
\nuse IEEE.STD_LOGIC_ARITH.ALL;\
\nuse IEEE.STD_LOGIC_UNSIGNED.ALL;\
\n\
\nentity digits_box is\
\n    Port (\
\n            clk:          in  STD_LOGIC;\
\n            reset:        in  STD_LOGIC;\
\n\
\n            bcd_input:    in  STD_LOGIC_VECTOR(NUM_BCD_DIGITS_GENERIC*4-1 downto 0);\
\n\
\n            scan_line_x:  in  STD_LOGIC_VECTOR(10 downto 0);\
\n            scan_line_y:  in  STD_LOGIC_VECTOR(10 downto 0);\
\n            --kHz:          in  STD_LOGIC;\
\n            red:          out STD_LOGIC_VECTOR(3 downto 0);\
\n            blue:         out STD_LOGIC_VECTOR(3 downto 0);\
\n            green:        out std_logic_vector(3 downto 0)\
\n          );\
\nend digits_box;\
\n\
\narchitecture Behavioral of digits_box is\
\n\
\n-- Internal Signals  -----------------------------------------------------------\
\n    type MAT is array (24 downto 0) of std_logic_vector(24 downto 0);\
\n    constant sig_E: Mat := (("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"));\
\n    constant sig_D: Mat := (("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("1111100000000000000000000"), ("1111100000000000000000000"), ("1111100000000000000000000"), ("1111100000000000000000000"), ("1111100000000000000000000"), ("1111100000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"));\
\n    constant sig_0: MAT := (("0000011111111111111100000"), ("0000011111111111111100000"), ("0000011111111111111100000"), ("0000011111111111111100000"), ("0000011111111111111100000"), ("1111100000000000000011111"), ("1111100000000000000011111"), ("1111100000000000000011111"), ("1111100000000000000011111"), ("1111100000000000000011111"), ("1111100000000000000011111"), ("1111100000000000000011111"), ("1111100000000000000011111"), ("1111100000000000000011111"), ("1111100000000000000011111"), ("1111100000000000000011111"), ("1111100000000000000011111"), ("1111100000000000000011111"), ("1111100000000000000011111"), ("1111100000000000000011111"), ("0000011111111111111100000"), ("0000011111111111111100000"), ("0000011111111111111100000"), ("0000011111111111111100000"), ("0000011111111111111100000"));\
\n    constant sig_1: MAT := (("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"), ("0000000000000000000000000"));\
\n    constant sig_2: MAT := (("1111100000000001111100000"), ("1111100000000001111100000"), ("1111100000000001111100000"), ("1111100000000001111100000"), ("1111100000000001111100000"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111111111000000000011111"), ("1111111111000000000011111"), ("1111111111000000000011111"), ("1111111111000000000011111"), ("1111111111000000000011111"), ("1111100000000001111100000"), ("1111100000000001111100000"), ("1111100000000001111100000"), ("1111100000000001111100000"), ("1111100000000001111100000"));\
\n    constant sig_3: MAT := (("0000011111000001111100000"), ("0000011111000001111100000"), ("0000011111000001111100000"), ("0000011111000001111100000"), ("0000011111000001111100000"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000000000000011111"), ("1111100000000000000011111"), ("1111100000000000000011111"), ("1111100000000000000011111"), ("1111100000000000000011111"));\
\n    constant sig_4: MAT := (("0000000000111110000000000"), ("0000000000111110000000000"), ("0000000000111110000000000"), ("0000000000111110000000000"), ("0000000000111110000000000"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("1111111111111111111111111"), ("0000000000111110000011111"), ("0000000000111110000011111"), ("0000000000111110000011111"), ("0000000000111110000011111"), ("0000000000111110000011111"), ("0000000000111111111100000"), ("0000000000111111111100000"), ("0000000000111111111100000"), ("0000000000111111111100000"), ("0000000000111111111100000"), ("0000000000111110000000000"), ("0000000000111110000000000"), ("0000000000111110000000000"), ("0000000000111110000000000"), ("0000000000111110000000000"));\
\n    constant sig_5: MAT := (("1111111111000000000011111"), ("1111111111000000000011111"), ("1111111111000000000011111"), ("1111111111000000000011111"), ("1111111111000000000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000000000000011111"), ("1111100000000000000011111"), ("1111100000000000000011111"), ("1111100000000000000011111"), ("1111100000000000000011111"), ("1111100000000001111111111"), ("1111100000000001111111111"), ("1111100000000001111111111"), ("1111100000000001111111111"), ("1111100000000001111111111"));\
\n    constant sig_6: MAT := (("0000011111000000000011111"), ("0000011111000000000011111"), ("0000011111000000000011111"), ("0000011111000000000011111"), ("0000011111000000000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("0000011111111111111100000"), ("0000011111111111111100000"), ("0000011111111111111100000"), ("0000011111111111111100000"), ("0000011111111111111100000"));\
\n    constant sig_7: MAT := (("0000000000000000000011111"), ("0000000000000000000011111"), ("0000000000000000000011111"), ("0000000000000000000011111"), ("0000000000000000000011111"), ("0000000000000001111111111"), ("0000000000000001111111111"), ("0000000000000001111111111"), ("0000000000000001111111111"), ("0000000000000001111111111"), ("0000000000111110000011111"), ("0000000000111110000011111"), ("0000000000111110000011111"), ("0000000000111110000011111"), ("0000000000111110000011111"), ("0000011111000000000011111"), ("0000011111000000000011111"), ("0000011111000000000011111"), ("0000011111000000000011111"), ("0000011111000000000011111"), ("1111100000000000000011111"), ("1111100000000000000011111"), ("1111100000000000000011111"), ("1111100000000000000011111"), ("1111100000000000000011111"));\
\n    constant sig_8: MAT := (("0000011111000001111100000"), ("0000011111000001111100000"), ("0000011111000001111100000"), ("0000011111000001111100000"), ("0000011111000001111100000"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("0000011111000001111100000"), ("0000011111000001111100000"), ("0000011111000001111100000"), ("0000011111000001111100000"), ("0000011111000001111100000"));\
\n    constant sig_9: MAT := (("0000000000111111111111111"), ("0000000000111111111111111"), ("0000000000111111111111111"), ("0000000000111111111111111"), ("0000000000111111111111111"), ("0000011111111110000011111"), ("0000011111111110000011111"), ("0000011111111110000011111"), ("0000011111111110000011111"), ("0000011111111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000111110000011111"), ("1111100000000001111100000"), ("1111100000000001111100000"), ("1111100000000001111100000"), ("1111100000000001111100000"), ("1111100000000001111100000"));\
\n\
\n    constant box_loc_x_min: STD_LOGIC_VECTOR(9 downto 0) := "0000000000";\
\n    constant box_loc_y_min: STD_LOGIC_VECTOR(9 downto 0) := "0000000000";\
\n    constant box_loc_x_max: STD_LOGIC_VECTOR(9 downto 0) := "1001111111"; -- 640-1 -- 640 is 1010000000\
\n    constant box_loc_y_max: STD_LOGIC_VECTOR(9 downto 0) := "0111011111"; -- 480-1 -- 480 is 0111100000\
\n    signal pixel_color:     STD_LOGIC_VECTOR(11 downto 0);\
\n   \
\n    signal current_digit_value: STD_LOGIC_VECTOR(3 downto 0); -- Value of the digit you are currently in (or 0s)\
\n    signal output_digit: MAT;\
\n\
\n    constant pos_start_x_sig_digit_d1:  STD_LOGIC_VECTOR(9 downto 0) := "0000010000"; -- 16\
\n    constant pos_start_x_sig_digit_d2:  STD_LOGIC_VECTOR(9 downto 0) := "0000101101"; -- 45\
\n    constant pos_start_x_sig_digit_d3:  STD_LOGIC_VECTOR(9 downto 0) := "0001001010"; -- 74\
\n    constant pos_start_x_sig_digit_d4:  STD_LOGIC_VECTOR(9 downto 0) := "0001100111"; -- 103\
\n    constant pos_end_x_sig_digit_d1:    STD_LOGIC_VECTOR(9 downto 0) := "0000101001"; -- 41\
\n    constant pos_end_x_sig_digit_d2:    STD_LOGIC_VECTOR(9 downto 0) := "0001000110"; -- 70\
\n    constant pos_end_x_sig_digit_d3:    STD_LOGIC_VECTOR(9 downto 0) := "0001100011"; -- 99\
\n    constant pos_end_x_sig_digit_d4:    STD_LOGIC_VECTOR(9 downto 0) := "0010000000"; -- 128\
\n    constant pos_start_y:               STD_LOGIC_VECTOR(9 downto 0) := "0000010000"; -- 16 -- All digits share these\
\n    constant pos_end_y:                 STD_LOGIC_VECTOR(9 downto 0) := "0000101001"; -- 41 -- All digits share these\
\n\
\n    signal currently_sig_digit_d1:      STD_LOGIC := \'0\';\
\n    signal currently_sig_digit_d2:      STD_LOGIC := \'0\';\
\n    signal currently_sig_digit_d4:      STD_LOGIC := \'0\';\
\n    signal currently_sig_digit_d3:      STD_LOGIC := \'0\';\
\n    signal pos_start_x_current_sig:     STD_LOGIC_VECTOR(9 downto 0); -- The pos_start_x_sig for the current digit\
\n    signal current_sig_x_offset:        integer := 0; -- Used for indexing the current sig_digit MAT\
\n    signal current_sig_y_offset:        integer := 0;\
\n\
\nbegin\
\n\
\n\
\n-- Internal processes  ---------------------------------------------------------\
\n    -- Figure out which digit (if any is currently being shown)\
\n        currently_sig_digit_d1 <= \'1\'\
\n                when (scan_line_x >= pos_start_x_sig_digit_d1) AND\
\n                     (scan_line_x <  pos_end_x_sig_digit_d1) AND\
\n                     (scan_line_y >= pos_start_y) AND\
\n                     (scan_line_y <  pos_end_y) \
\n                else \'0\';\
\n        currently_sig_digit_d2 <= \'1\'\
\n                when (scan_line_x >= pos_start_x_sig_digit_d2) AND\
\n                     (scan_line_x <  pos_end_x_sig_digit_d2) AND\
\n                     (scan_line_y >= pos_start_y) AND\
\n                     (scan_line_y <  pos_end_y) \
\n                else \'0\';\
\n        currently_sig_digit_d3 <= \'1\'\
\n                when (scan_line_x >= pos_start_x_sig_digit_d3) AND\
\n                     (scan_line_x <  pos_end_x_sig_digit_d3) AND\
\n                     (scan_line_y >= pos_start_y) AND\
\n                     (scan_line_y <  pos_end_y) \
\n                else \'0\';\
\n        currently_sig_digit_d4 <= \'1\'\
\n                when (scan_line_x >= pos_start_x_sig_digit_d4) AND\
\n                     (scan_line_x <  pos_end_x_sig_digit_d4) AND\
\n                     (scan_line_y >= pos_start_y) AND\
\n                     (scan_line_y <  pos_end_y) \
\n                else \'0\';\
\n\
\n    -- Get the x & y offset INSIDE a digit\
\n        -- The starting pos of the digit you are currently in (or 0s if not in digit)\
\n        pos_start_x_current_sig <=   pos_start_x_sig_digit_d1 when (currently_sig_digit_d1 = \'1\')\
\n                                else pos_start_x_sig_digit_d2 when (currently_sig_digit_d2 = \'1\')\
\n                                else pos_start_x_sig_digit_d3 when (currently_sig_digit_d3 = \'1\')\
\n                                else pos_start_x_sig_digit_d4 when (currently_sig_digit_d4 = \'1\')\
\n                                else (others => \'0\');\
\n        -- Determine how many pixels from the start of the current digit the scan lines are\
\n        current_sig_x_offset <= CONV_INTEGER(UNSIGNED(scan_line_x - pos_start_x_current_sig));\
\n        current_sig_y_offset <= CONV_INTEGER(UNSIGNED(scan_line_y - pos_start_y));\
\n\
\n    -- Get the values of the current digits\
\n        current_digit_value <=\
\n                bcd_input(NUM_BCD_DIGITS_GENERIC*4-1 downto 3*4) when (currently_sig_digit_d1 = \'1\')\
\n                else bcd_input(4*3-1 downto 2*4) when (currently_sig_digit_d2 = \'1\')\
\n                else bcd_input(4*2-1 downto 1*4) when (currently_sig_digit_d3 = \'1\')\
\n                else bcd_input(4*1-1 downto 0*4) when (currently_sig_digit_d4 = \'1\')\
\n                else (others => \'0\');\
\n \
\n        CURRENT_DIGIT: process(current_digit_value)\
\n        begin\
\n            case current_digit_value is\
\n                when "0000" => output_digit <= sig_0;\
\n                when "0001" => output_digit <= sig_1;\
\n                when "0010" => output_digit <= sig_2;\
\n                when "0011" => output_digit <= sig_3;\
\n                when "0100" => output_digit <= sig_4;\
\n                when "0101" => output_digit <= sig_5;\
\n                when "0110" => output_digit <= sig_6;\
\n                when "0111" => output_digit <= sig_7;\
\n                when "1000" => output_digit <= sig_8;\
\n                when "1001" => output_digit <= sig_9;\
\n                when "1100" => output_digit <= sig_D;\
\n                when others => output_digit <= sig_E;\
\n            end case;\
\n        end process;\
\n\
\n    -- Select the color\
\n        pixel_color <= "111011111111"\
\n                  when  ((output_digit(current_sig_x_offset)(current_sig_y_offset) = \'1\')) AND \
\n                         ((currently_sig_digit_d1 = \'1\') OR\
\n                         (currently_sig_digit_d2 = \'1\') OR\
\n                         (currently_sig_digit_d4 = \'1\') OR\
\n                         (currently_sig_digit_d3 = \'1\'))\
\n                else\
\n                         "000000000000"; -- represents background color\
\n\
\n                                \
\nred   <= pixel_color(11 downto 8);\
\ngreen <= pixel_color(7 downto 4);\
\nblue  <= pixel_color(3 downto 0);\
\n\
\n\
\nend Behavioral;\
'


downcounter = '\nlibrary IEEE;\
\nuse IEEE.STD_LOGIC_1164.ALL;\
\nuse IEEE.NUMERIC_STD.ALL;\
\nuse IEEE.STD_LOGIC_UNSIGNED.ALL;\
\n\
\nentity downcounter is\
\n	Generic ( 	period: integer:= 4;				\
\n					WIDTH: integer:= 3);\
\n		Port ( clk : in  STD_LOGIC;\
\n				  reset : in  STD_LOGIC;\
\n				  enable : in  STD_LOGIC;\
\n				  zero : out  STD_LOGIC;\
\n				  value: out STD_LOGIC_VECTOR(WIDTH-1 downto 0));\
\nend downcounter;\
\n\
\narchitecture Behavioral of downcounter is\
\n	signal 	current_count: std_logic_vector(WIDTH-1 downto 0);\
\n	signal 	i_zero: 			std_logic;	\
\n	\
\n	-- Convert the max counter to a logic vector (this is done during synthesis) \
\n	constant max_count: 		std_logic_vector(WIDTH-1 downto 0) := \
\n									std_logic_vector(to_unsigned(period, WIDTH));\
\n	-- Create a logic vector of proper length filled with zeros (also done during synthesis)\
\n	constant zeros: 			std_logic_vector(WIDTH-1 downto 0) := (others => \'0\');\
\n	\
\nbegin\
\n\
\ncount: process(clk,reset) begin\
\n	if (reset = \'1\') then					-- Asynchronous reset\
\n        current_count 	<= max_count;\
\n        i_zero 			<= \'0\';\
\n	elsif (rising_edge(clk)) then \
\n        if (enable = \'1\') then				-- When counter is enabled\
\n            if (current_count = zeros) then\
\n                current_count 	<= max_count;\
\n                i_zero 			<= \'1\';\
\n            else \
\n                current_count 	<= current_count - \'1\';\
\n                i_zero 			<= \'0\';\
\n            end if;\
\n		else \
\n			i_zero <= \'0\';\
\n		end if;\
\n	end if;\
\nend process;\
\n\
\n-- Connect internal signals to output\
\nvalue <= current_count;	\
\nzero <= i_zero;		-- Connect internal signals to output\
\n\
\nend Behavioral;'



sync_signals_generator = '\nlibrary IEEE;\
\nuse IEEE.STD_LOGIC_1164.ALL;\
\nuse IEEE.STD_LOGIC_ARITH.ALL;\
\nuse IEEE.STD_LOGIC_UNSIGNED.ALL;\
\n\
\nentity sync_signals_generator is\
\n    Port ( pixel_clk : in  STD_LOGIC;\
\n           reset : in  STD_LOGIC;\
\n           hor_sync: out STD_LOGIC;\
\n           ver_sync: out STD_LOGIC;\
\n           blank: out STD_LOGIC;\
\n           scan_line_x: out STD_LOGIC_VECTOR(10 downto 0);\
\n           scan_line_y: out STD_LOGIC_VECTOR(10 downto 0)\
\n          );\
\nend sync_signals_generator;\
\n\
\narchitecture Behavioral of sync_signals_generator is\
\n	\
\n-- VGA Sync definitions (DON\'T CHANGE THESE)\
\n-- Horizontal definitions (measured in # of clock cycles)\
\nconstant h_disp_time: integer:= 640; -- horizontal display area (640)\
\nconstant h_sync_pulse: integer:= 800; -- maximum horizontal amount (limit)(800)\
\nconstant h_front_porch: integer:= 16; -- h. front porch\
\nconstant h_back_porch: integer:= 48;	-- h. back porch\
\nconstant h_pulse_width: integer:= 96;	-- h. pulse width\
\n-- Vertical definitions (measured in # of horiz lines)\
\nconstant v_disp_time: integer:= 480; -- vertical display area\
\nconstant v_sync_pulse: integer:= 521; -- maximum vertical amount (limit) 521\
\nconstant v_front_porch: integer:= 10;	-- v. front porch 10\
\nconstant v_back_porch: integer:= 29;	-- v. back porch 29\
\nconstant v_pulse_width: integer:= 2;	-- v. pulse width 2  	\
\n	\
\nsignal current_hor_pos: std_logic_vector(10 downto 0) := (others => \'0\');\
\nsignal current_ver_pos: std_logic_vector(10 downto 0) := (others => \'0\');\
\nsignal hor_blank, ver_blank, i_blank: std_logic;\
\n\
\nbegin\
\n	PixelPosition: process(pixel_clk, reset)\
\n	begin\
\n	    if (reset = \'1\') then\
\n            -- Reset all outputs\
\n            current_hor_pos <= (others => \'0\');\
\n            current_ver_pos <= (others => \'0\');	    \
\n		elsif (rising_edge(pixel_clk)) then\
\n            if current_hor_pos < h_sync_pulse-1 then\
\n                current_hor_pos <= current_hor_pos + 1;\
\n            else\
\n                if current_ver_pos < v_sync_pulse-1 then\
\n                    current_ver_pos <= current_ver_pos + 1;\
\n                else\
\n                   -- Resets Vertical position (reached bottom of screen)\
\n                    current_ver_pos <= (others => \'0\');		\
\n                end if;\
\n                -- Resets Horizontal position (reached right side of screen)\
\n                current_hor_pos <= (others => \'0\');			\
\n            end if;	\
\n		end if;\
\n	end process PixelPosition;\
\n\
\n-- Complete the description with relevant VERTICAL signals (ver_sync, ver_blank and scan_line_y)\
\nhor_sync <= \'0\' when current_hor_pos < h_pulse_width else \'1\';\
\n\
\nhor_blank <= \'0\' when (current_hor_pos >= h_pulse_width + h_back_porch) and \
\n                      (current_hor_pos < h_pulse_width + h_back_porch + h_disp_time) else \'1\';\
\n\
\nscan_line_x <= (current_hor_pos - h_pulse_width - h_back_porch) when i_blank = \'0\' else (others => \'0\');\
\n\
\n-- ADDED:\
\nver_sync <= \'0\' when current_ver_pos < v_pulse_width else \'1\';\
\nver_blank <= \'0\' when (current_ver_pos >= v_pulse_width + v_back_porch) and \
\n                      (current_ver_pos < v_pulse_width + v_back_porch + v_disp_time) else \'1\';\
\nscan_line_y <= (current_ver_pos - v_pulse_width - v_back_porch) when i_blank = \'0\' else (others => \'0\');\
\n\
\ni_blank	<= \'1\' when hor_blank = \'1\' or ver_blank = \'1\' else \'0\';\
\nblank <= i_blank;\
\nend Behavioral;\
'


vga_module = '\nlibrary IEEE;\
\nuse IEEE.STD_LOGIC_1164.ALL;\
\n\
\nentity vga_module is\
\n    Port (\
\n            clk         : in  STD_LOGIC;\
\n            reset       : in  STD_LOGIC;\
\n            distance_bcd: in  STD_LOGIC_VECTOR(NUM_BCD_DIGITS_GENERIC*4-1 downto 0);\
\n            red         : out STD_LOGIC_VECTOR(3 downto 0);\
\n            green       : out STD_LOGIC_VECTOR(3 downto 0);\
\n            blue        : out STD_LOGIC_VECTOR(3 downto 0);\
\n            hsync       : out STD_LOGIC;\
\n            vsync       : out STD_LOGIC\
\n    );\
\nend vga_module;\
\n\
\narchitecture Behavioral of vga_module is\
\n-- Modules ---------------------------------------------------------------------\
\n    component sync_signals_generator is\
\n        Port (\
\n            pixel_clk       : in  STD_LOGIC;\
\n            reset           : in  STD_LOGIC;\
\n            hor_sync        : out STD_LOGIC;\
\n            ver_sync        : out STD_LOGIC;\
\n            blank           : out STD_LOGIC;\
\n            scan_line_x     : out STD_LOGIC_VECTOR(10 downto 0);\
\n            scan_line_y     : out STD_LOGIC_VECTOR(10 downto 0)\
\n        );\
\n    end component;\
\n    component clock_divider is\
\n        Port (\
\n            clk             : in  STD_LOGIC;\
\n            reset           : in  STD_LOGIC;\
\n            enable          : in  STD_LOGIC;\
\n            kHz             : out STD_LOGIC;      \
\n            seconds_port    : out STD_LOGIC_VECTOR(4-1 downto 0); -- unused\
\n            ten_seconds_port: out STD_LOGIC_VECTOR(3-1 downto 0); -- unused\
\n            minutes_port    : out STD_LOGIC_VECTOR(4-1 downto 0); -- unused\
\n            ten_minutes_port: out STD_LOGIC_VECTOR(3-1 downto 0); -- unused\
\n            twentyfive_MHz  : out STD_LOGIC;\
\n            --daHz            : out STD_LOGIC -- update digits every tenth of a second\
\n            Hz              : out STD_LOGIC -- update digits every second\
\n        );\
\n    end component;\
\n    component digits_box is\
\n        Port (\
\n            clk:          in  STD_LOGIC;\
\n            reset:        in  STD_LOGIC;\
\n            bcd_input:    in  STD_LOGIC_VECTOR(NUM_BCD_DIGITS_GENERIC*4-1 downto 0);\
\n            scan_line_x:  in  STD_LOGIC_VECTOR(10 downto 0);\
\n            scan_line_y:  in  STD_LOGIC_VECTOR(10 downto 0);\
\n            --kHz:          in  STD_LOGIC;\
\n            red:          out STD_LOGIC_VECTOR(3 downto 0);\
\n            blue:         out STD_LOGIC_VECTOR(3 downto 0);\
\n            green:        out std_logic_vector(3 downto 0)\
\n        );\
\n    end component;\
\n\
\n-- Internal Signals ------------------------------------------------------------\
\n    -- Clock divider signals:\
\n    --signal i_kHz, i_daHz, i_pixel_clk: std_logic;\
\n    signal i_kHz, i_Hz, i_pixel_clk: std_logic;\
\n    -- Sync module signals:\
\n    signal vga_blank : std_logic;\
\n    signal scan_line_x, scan_line_y: STD_LOGIC_VECTOR(10 downto 0);\
\n    -- Box size signals:\
\n    signal inc_box, dec_box: std_logic;\
\n\
\n    signal i_distance_bcd: STD_LOGIC_VECTOR(NUM_BCD_DIGITS_GENERIC*4-1 downto 0);\
\n\
\nbegin\
\n-- Module Instantiation --------------------------------------------------------\
\n    DIVIDER: clock_divider\
\n        Port map (\
\n                clk              => clk,\
\n                reset            => reset,\
\n                kHz              => i_kHz,\
\n                twentyfive_MHz   => i_pixel_clk,\
\n                enable           => \'1\',\
\n                seconds_port     => open,\
\n                ten_seconds_port => open,\
\n                minutes_port     => open,\
\n                ten_minutes_port => open,\
\n                --daHz             => i_daHz\
\n                Hz               => i_Hz\
\n        );\
\n    VGA_SYNC: sync_signals_generator\
\n        Port map(\
\n                pixel_clk    => i_pixel_clk,\
\n                reset        => reset,\
\n                hor_sync     => hsync,\
\n                ver_sync     => vsync,\
\n                blank        => vga_blank,\
\n                scan_line_x  => scan_line_x,\
\n                scan_line_y  => scan_line_y\
\n        );\
\n\
\n    DELAY_DIGITS: process(i_Hz, reset) -- only update the digits once a second on the vga\
\n    begin\
\n        if (reset = \'1\') then\
\n            i_distance_bcd <= (others => \'0\');\
\n        elsif (rising_edge(i_Hz)) then\
\n        --elsif (rising_edge(i_daHz)) then\
\n            i_distance_bcd <= distance_bcd;\
\n        end if;\
\n    end process;\
\n\
\n\
\n    BOX: digits_box\
\n        Port map (\
\n                clk          => clk,\
\n                reset        => reset,\
\n                bcd_input    => i_distance_bcd,\
\n                scan_line_x  => scan_line_x,\
\n                scan_line_y  => scan_line_y,\
\n                --kHz          => i_kHz,\
\n                red          => red,\
\n                blue         => blue,\
\n                green        => green\
\n        );\
\n\
\n\
\nend Behavioral;\
'


# Main module ------------------------------------------------------------------

main_module = '\nlibrary IEEE;\
\nuse IEEE.STD_LOGIC_1164.ALL;\
\nuse IEEE.STD_LOGIC_UNSIGNED.ALL;\
\n\
\nentity main_module is\
\n    Port ( \
\n            -- Main signals\
\n            reset      : in  STD_LOGIC;\
\n            clk        : in  STD_LOGIC;\
\n            -- Select units\
\n            en_dists_cm: in STD_LOGIC;\
\n            en_dists_in: in STD_LOGIC;\
\n            -- VGA signals\
\n            red       : out STD_LOGIC_VECTOR(3 downto 0);\
\n            green     : out STD_LOGIC_VECTOR(3 downto 0);\
\n            blue      : out STD_LOGIC_VECTOR(3 downto 0);\
\n            hsync     : out STD_LOGIC;\
\n            vsync     : out STD_LOGIC;\
\n            -- Comparator signals\
\n            comparator : in  STD_LOGIC; -- If 1: increase voltage, If 0: decrease\
\n\
\n            en_led     : in  STD_LOGIC; -- Enable the LEDs\
\n            led        : out STD_LOGIC_VECTOR(9-1 downto 0); -- LEDs displaying the current value of the comparator\
\n            pwm_out    : out STD_LOGIC\
\n          );\
\nend main_module;\
\n\
\n\
\narchitecture Behavioral of main_module is\
\n-- Modules ---------------------------------------------------------------------\
\n    component dynamic_clk is\
\n        Port (\
\n                clk         : in  STD_LOGIC;\
\n                reset       : in  STD_LOGIC;\
\n                voltage     : in  STD_LOGIC_VECTOR(9-1 downto 0); -- 9 is width\
\n                out_clk     : out STD_LOGIC\
\n         );\
\n    end component;\
\n    component signal_gen is\
\n        Port (\
\n                clk         : in  STD_LOGIC;\
\n                reset       : in  STD_LOGIC;\
\n                comparator  : in  STD_LOGIC;\
\n                voltage     : out STD_LOGIC_VECTOR(9-1 downto 0); -- 9 is width\
\n                pwm_out     : out STD_LOGIC\
\n         );\
\n    end component;\
\n    component estimator is\
\n        Port (\
\n                clk        : in  STD_LOGIC;\
\n                reset      : in  STD_LOGIC;\
\n                en_dists_cm: in  STD_LOGIC;\
\n                en_dists_in: in  STD_LOGIC;\
\n                voltage    : in  STD_LOGIC_VECTOR(9-1 downto 0); -- 9 is the width\
\n                distance   : out STD_LOGIC_VECTOR(NUM_BCD_DIGITS_GENERIC*4-1 downto 0)\
\n         );\
\n    end component;\
\n    component vga_module is\
\n        Port (\
\n                clk         : in  STD_LOGIC;\
\n                reset       : in  STD_LOGIC;\
\n                distance_bcd: in  STD_LOGIC_VECTOR(NUM_BCD_DIGITS_GENERIC*4-1 downto 0); -- estimated distance -- 3 digits of 4 bits (bcd)\
\n                red         : out STD_LOGIC_VECTOR(3 downto 0);\
\n                green       : out STD_LOGIC_VECTOR(3 downto 0);\
\n                blue        : out STD_LOGIC_VECTOR(3 downto 0);\
\n                hsync       : out STD_LOGIC;\
\n                vsync       : out STD_LOGIC\
\n         );\
\n    end component;\
\n\
\n-- Internal Signals ------------------------------------------------------------\
\n    signal voltage : STD_LOGIC_VECTOR (9-1 downto 0); -- the approximate voltage -- 9 is width\
\n    signal distance: STD_LOGIC_VECTOR (NUM_BCD_DIGITS_GENERIC*4-1 downto 0); -- the estimated distance (0.0-30.0) needs at least 9 bits -- 9 is width\
\n    signal dyn_clk : STD_LOGIC := \'0\'; -- A clock that slows down when you don\'t need to update as quickly\
\nbegin\
\n\
\n-- Module instantiations -------------------------------------------------------\
\n    DYNAMIC_POWER_CONSUMPTION: dynamic_clk\
\n        Port map (\
\n                clk         => clk,\
\n                reset       => reset,\
\n                voltage     => voltage,\
\n                out_clk     => dyn_clk\
\n            );\
\n    ADC_SIGNAL_GEN: signal_gen\
\n        Port map (\
\n                clk         => clk,\
\n                reset       => reset,\
\n                comparator  => comparator,\
\n                voltage     => voltage,\
\n                pwm_out     => pwm_out\
\n            );\
\n    DISTANCE_ESTIMATOR: estimator -- Note: remeber that the RNN state is internal\
\n        Port map (\
\n                clk         => dyn_clk, -- Estimation doesn\'t need to be as fast if the voltage is changing slowly\
\n                reset       => reset,\
\n                en_dists_cm => en_dists_cm,\
\n                en_dists_in => en_dists_in,\
\n                voltage     => voltage,\
\n                distance    => distance\
\n            );\
\n    VGA_DISPLAY: vga_module\
\n        Port map ( \
\n                clk         => clk,\
\n                reset       => reset,\
\n                distance_bcd=> distance,\
\n                red         => red,\
\n                green       => green,\
\n                blue        => blue,\
\n                hsync       => hsync,\
\n                vsync       => vsync\
\n            );\
\n\
\n-- LEDs & fun stuff\
\n    SHOW_LEDS : process(en_led)\
\n    begin\
\n        if (en_led = \'1\') then\
\n            led <= voltage;\
\n        else\
\n            led <= (others => \'0\');\
\n        end if ;\
\n    end process ; -- SHOW_LEDS\
\n--led <= voltage;\
\n\
\nend Behavioral;\
'